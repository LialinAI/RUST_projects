#[derive(Debug)] // so we can inspect the state in a minute
enum UsState {
    Alabama,
    Alaska,
    // --snip--
}

enum Coin {
    Penny,
    Nickel,
    Dime,
    Quarter(UsState),
}

fn value_in_cents(coin: Coin) -> u8 {
// Ветки состоят из двух частей: шаблон и некоторый код. Здесь первая ветка имеет шаблон,
// который является значением Coin::Penny, затем идёт оператор =>, который разделяет шаблон
// и код для выполнения. Код в этом случае - это просто значение 1. Каждая ветка отделяется
// от последующей при помощи запятой.

// Когда выполняется выражение match, оно сравнивает полученное значение 
// с образцом каждой ветки по порядку. Если шаблон совпадает со значением, то выполняется код,
// связанный с этим шаблоном. Если этот шаблон не соответствует значению, то выполнение продолжается
// со следующей ветки, так же, как в автомате по сортировке монет.

// Код, связанный с каждой веткой, является выражением, а полученное значение выражения
// в соответствующей ветке — это значение, которое возвращается для всего выражения match.

///////

// Есть ещё одно полезное качество у веток в выражении match: они могут привязываться к частям тех значений,
// которые совпали с шаблоном. Благодаря этому можно извлекать значения из вариантов перечисления.

    match coin {
        Coin::Penny => { // Если вы хотите выполнить несколько строк кода в одной ветви,
                println!("Lucky penny!");// вы должны использовать фигурные скобки, а запятая после этой ветви необязательна. 
                1
        }
        Coin::Nickel => 5,
        Coin::Dime => 10,
        // В выражении match для этого кода мы добавляем переменную с именем state в шаблон,
        // который соответствует значениям варианта Coin::Quarter. Когда Coin::Quarter совпадёт
        // с шаблоном, переменная state будет привязана к значению штата этого четвертака. Затем
        // мы сможем использовать state в коде этой ветки
        Coin::Quarter(state) => {
            println!("State quarter from {:?}!", state);
            25
        }
    }
}

fn main() {

    let c = Coin::Penny;
    let q = Coin::Quarter(UsState::Alaska);

    println!("{}", value_in_cents(q));

    //////////

    let five = Some(5);
    let six = plus_one(five);
    let none = plus_one(None);

    println!("{:?}, {:?}", six, none)

    ////////// ПРИМЕР!!!!!

    // let dice_roll = 9;
    // match dice_roll {
    //     3 => add_fancy_hat(), // функция для получения шляпы
    //     7 => remove_fancy_hat(), //функция потери шляпы 
    //     other => move_player(other), //функция для перемещения игрока по игровому полю на other пунктов
    // }

    // let dice_roll = 9;
    // match dice_roll {
    //     3 => add_fancy_hat(),
    //     7 => remove_fancy_hat(),
    //     _ => reroll(), // если выпало не 3 и не 7, то кубик перебрасывается
    // } // нижнее подчеркивание является шаблоном любого значения, без явного указания

    // let dice_roll = 9;
    // match dice_roll {
    //     3 => add_fancy_hat(),
    //     7 => remove_fancy_hat(),
    //     _ => (), // если мы не хотим вообще выполнять какое-либо действие, то используем (), что является пустым типом кортежа
    // }

}


//  Функция, которая принимает Option<i32> и если есть значение внутри, то добавляет 1 к существующему значению.
// Если значения нет, то функция должна возвращать значение None и не пытаться выполнить какие-либо операции.

// В match должны быть прописаны все возможные варианты, иначе возникнет ошибка
// Если в данном примере не указать None => None, то возникнет ошибка, компилятор знает, что мы объяли не ве возможные значения

fn plus_one(x: Option<i32>) -> Option<i32> {
    match x {
        None => None,
        Some(i) => Some(i + 1),
    }
}

