// В настоящее время для обозначения IP-адресов используются два основных стандарта:
// четвёртая и шестая версии. Поскольку это единственно возможные варианты IP-адресов,
// с которыми может столкнуться наша программа, мы можем перечислить все возможные варианты,
// откуда перечисление и получило своё название.

// На мой взгляд перечисление уместо использовать для разделения фондов, акций и облигаций
// Я реализовывал это через дополнительное поле в бд, но благодаря перечислению это можно
// Сделать проще

//Пречисление
enum IpAddrKind {
    V4,
    V6,
}

// #[derive(Debug)]
struct IpAddr {
    kind: IpAddrKind,
    address: String,
}

// Однако представление этой же концепции с помощью перечисления более лаконично:
// вместо того, чтобы помещать перечисление в структуру, мы можем поместить данные
// непосредственно в любой из вариантов перечисления. Мы прикрепляем данные к каждому
// варианту перечисления напрямую, поэтому нет необходимости в дополнительной структуре.

//Ещё одно преимущество использования перечисления вместо структуры заключается в том, что
// каждый вариант перечисления может иметь разное количество ассоциированных данных представленных в разных типах. 

enum IpAddrNew {
    V4(u8, u8, u8, u8),
    V6(String),
}

//  Мы можем добавлять любой тип данных в значение перечисления: строку, число, структуру 

// Слева и справа по сути одно и то же
enum Message {                         // struct QuitMessage; // unit struct
    Quit,                              // struct MoveMessage {
    Move { x: i32, y: i32 },           //     x: i32,
    Write(String),                     //     y: i32,
    ChangeColor(i32, i32, i32),        // }                      
                                       // struct WriteMessage(String); // tuple struct
                                       // struct ChangeColorMessage(i32, i32, i32); // tuple struct
}

impl Message { // Также для enum можно определять методы с помощью impl 

    fn call(&self){
    
    }
}

// Когда есть значение Some, мы знаем, что значение присутствует и содержится внутри Some.
// Когда есть значение None, это означает то же самое, что и null в некотором смысле: у нас
// нет действительного значения.

// Когда у нас есть значение типа на подобие i8, компилятор гарантирует, что у нас всегда есть
// допустимое значение типа. Мы можем уверенно продолжать работу, не проверяя его на null перед
// использованием. Однако, когда у нас есть значение типа Option<T> (где T - это любое значение
// любого типа T, упакованное в Option, например значение типа i8 или String), мы должны беспокоиться
// о том, что значение типа T возможно не имеет значения (является вариантом None), и компилятор
// позаботится о том, чтобы мы обработали такой случай, прежде чем мы бы попытались использовать None значение.

enum Option<T> {
    None,
    Some(T),
}

fn main() {

    let home = IpAddr {
        kind: IpAddrKind::V4, // экземпляр перечисления
        address: String::from("127.0.0.1"),
    };

    let loopback = IpAddr {
        kind: IpAddrKind::V6, // экземпляр перечисления
        address: String::from("::1"),
    };

    ////////

    let home1 = IpAddrNew::V4(127, 0, 0, 1); // экземпляр перечисления

    let loopback2 = IpAddrNew::V6(String::from("::1")); // экземпляр перечисления

    ////////

    // В теле метода будет использоваться self для получения значение того объекта,
    // у которого мы вызвали этот метод. В этом примере мы создали переменную m,
    // содержащую значение Message::Write(String::from("hello")), и именно это значение
    // будет представлять self в теле метода call при выполнении m.call().

    let m = Message::Write(String::from("hello"));
    m.call();

    ////////


    // Тип some_number - Option<i32>. Тип some_char - Option<char>, это другой тип.
    // Rust может вывести эти типы, потому что мы указали значение внутри варианта Some.
    // Для absent_number Rust требует, чтобы мы аннотировали общий тип для Option: компилятор
    // не может вывести тип, который будет в Some, глядя только на значение None. Здесь мы
    // сообщаем Rust, что absent_number должен иметь тип Option<i32>.

    let some_number = Some(5);
    let some_char = Some('e');

    let absent_number: Option<i32> = Option::None;
    
}
