//Rust реализует функциональность для печати отладочной информации, но не включает
// (не выводит) её по умолчанию. Мы должны явно включить эту функциональность для
// нашей структуры. Чтобы это сделать, добавляем внешний атрибут
// #[derive(Debug)] сразу перед определением структуры

#[derive(Debug)]
struct Rectangle { // объявление структуры
    width: u32,
    height: u32,
}

fn main() {
    let rect1 = Rectangle { // экземпляр структуры
        width: 30,
        height: 50,
    };

    // Ввод спецификатора :? внутри фигурных скобок говорит макросу println!,
    // что мы хотим использовать другой формат вывода, известный как Debug.
    println!("rect1 is {:?}", rect1); 

    println!(
        "The area of the rectangle is {} square pixels.",
        area(&rect1)
    );

    // Другой способ распечатать значение в формате Debug — использовать макрос dbg!,
    // который становится владельцем выражения (в отличие от println!, принимающего ссылку),
    // печатает номер файла и строки, где происходит вызов макроса dbg!, вместе с результирующим
    // значением этого выражения и возвращает владение на значение.

    // Можем написать макрос dbg! вокруг выражения 30 * scale, потому что dbg! возвращает владение
    // значения выражения. Поле width получит то же значение, как если бы у нас не было вызова dbg!.
    // Мы не хотим, чтобы макрос dbg! становился владельцем rect1, поэтому используем ссылку на rect1 в следующем вызове.

    let scale = 2;
    let rect2 = Rectangle {
        width: dbg!(20 * scale),
        height: 60
    };

    dbg!(&rect2);
}

fn area(rectangle: &Rectangle) -> u32 { // вычисление площади
    rectangle.width * rectangle.height // обращение к полям структуры
}z